常用操作符
在上一个章节 
我很还通过just直接快捷的生成了Flowable 
我们还通过将drwable通过map操作符转换成了 bitmap进以下一流的操作

这些操作符使整个逻辑流程很美 很漂亮 很sexy~~~ 
比那些蜜汁缩进美了不是一点半点， 我们下面来个比较复杂的例子，大家对比一下(用的RxJava1.0，意思一下)

//-----------------------------------蜜汁缩进--嵌套循环--回调地狱 -----------------------------------------------------------

    /** * 实现的功能:获取assets文件夹下所有文件夹中的jpg图片,并且将所有的图片画到一个ImageView上,没有实际的用处,只是为了说明问题--- 谜之缩进--嵌套循环--回调地狱 * 不使用RxJava的写法-- 谜之缩进--回调地狱 */
    //思路:需要以下6个步骤完成
    //1:遍历获取assets文件夹下所有的文件夹的名称
    //2:遍历获取获取assets文件夹下某个文件夹中所有图片路径的集合
    //3:过滤掉非JPG格式的图片
    //4:获取某个路径下图片的bitmap
    //5:将Bitmap绘制到画布上
    //6:循环结束后更新UI,给ImageView设置最后绘制完成后的Bitmap,隐藏ProgressBar
    private void miZhiSuoJinAndNestedLoopAndCallbackHell() {
        new Thread(new Runnable() {
            @Override
            public void run() {

                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mProgressBar.setVisibility(View.VISIBLE);
                    }
                });
                //1:遍历获取assets文件夹下所有的文件夹的名称
                ArrayList<String> assetsFolderNameList = ImageNameFactory.getAssetImageFolderName();

                for (String folderName : assetsFolderNameList) {

                    //2:遍历获取获取assets文件夹下某个文件夹中所有图片路径的集合
                    ArrayList<String> imagePathList = ImageUtils.getAssetsImageNamePathList(getApplicationContext(), folderName);

                    for (final String imagePathName : imagePathList) {
                        //3:过滤掉非JPG格式的图片
                        if (imagePathName.endsWith(JPG)) {

                            //4:获取某个路径下图片的bitmap
                            final Bitmap bitmap = ImageUtils.getImageBitmapFromAssetsFolderThroughImagePathName(getApplicationContext(), imagePathName, Constant.IMAGE_WITH, Constant.IMAGE_HEIGHT);
                            runOnUiThread(new Runnable() {
                                @Override
                                public void run() {
                                    //Logger.d(mCounter + ":" + imagePathName);

                                    //5:将Bitmap绘制到画布上
                                    createSingleImageFromMultipleImages(bitmap, mCounter);
                                    mCounter++;

                                }
                            });
                        }
                    }
                }


                //6:循环结束后更新UI,给ImageView设置最后绘制完成后的Bitmap,隐藏ProgressBar
                runOnUiThread(new Runnable() {
                    @Override
                    public void run() {
                        mImageView.setImageBitmap(mManyBitmapSuperposition);
                        mProgressBar.setVisibility(View.GONE);
                    }
                });

            }
        }).start();
    }
//-----------------------------------RxJava的实现--链式调用--十分简洁 -----------------------------------------------------------


    private void rxJavaSolveMiZhiSuoJinAndNestedLoopAndCallbackHell() {
        //1:被观察者:

        //2:数据转换

        //3:设置事件的产生发生在IO线程

        //4:设置事件的消费发生在主线程

        //5:观察者

        //6:订阅:被观察者被观察者订阅
        mGoToRecycleImageView = false;
        Observable.from(ImageNameFactory.getAssetImageFolderName())
                //assets下一个文件夹的名称,assets下一个文件夹中一张图片的路径
                .flatMap(new Func1<String, Observable<String>>() {
                    @Override
                    public Observable<String> call(String folderName) {
                        return Observable.from(ImageUtils.getAssetsImageNamePathList(getApplicationContext(), folderName));
                    }
                })
                //过滤,筛选出jpg图片
                .filter(new Func1<String, Boolean>() {
                    @Override
                    public Boolean call(String imagePathNameAll) {
                        return imagePathNameAll.endsWith(JPG);
                    }
                })
                //将图片路径转换为对应图片的Bitmap
                .map(new Func1<String, Bitmap>() {
                    @Override
                    public Bitmap call(String imagePathName) {
                        return ImageUtils.getImageBitmapFromAssetsFolderThroughImagePathName(getApplicationContext(), imagePathName, Constant.IMAGE_WITH, Constant.IMAGE_HEIGHT);
                    }
                })
                .map(new Func1<Bitmap, Void>() {
                    @Override
                    public Void call(Bitmap bitmap) {
                        createSingleImageFromMultipleImages(bitmap, mCounter);
                        mCounter++;
                        return null;
                    }
                })
                .subscribeOn(Schedulers.io())//设置事件的产生发生在IO线程
                .doOnSubscribe(new Action0() {
                    @Override
                    public void call() {
                        mProgressBar.setVisibility(View.VISIBLE);
                    }
                })
                .observeOn(AndroidSchedulers.mainThread())//设置事件的消费发生在主线程
                .subscribe(new Subscriber<Void>() {
                    @Override
                    public void onCompleted() {
                        mImageView.setImageBitmap(mManyBitmapSuperposition);
                        mProgressBar.setVisibility(View.GONE);
                    }

                    @Override
                    public void onError(Throwable e) {
                        //Toast.makeText(MainActivity.this, ""+e.getMessage(), Toast.LENGTH_SHORT).show();
                    }

                    @Override
                    public void onNext(Void aVoid) {

                    }
                });
    }
操作符部分一览 （基于Rxjava1.0）
Combining Obsercables(Observable的组合操作符)
操作符	功能
combineLatest	两个Observable产生的结果合并成新Observable，任意Observable产生的结果和另一个Observable最后产生的结果按规则合并
join	like combineLatest 能控制每个Observable产生结果的生命周期，在每个结果的生命周期内，与另一个Observable产生的结果按规则合并
groupJoin	like join 暂不知其他区别
==merge==	==按照两个Observable的提交结果的时间顺序，对Observable合并。时间按某Observable完成的最小时间==
mergeDelayError	合并的某一个Observable中出现错误，把错误放到所有结果都合并完成之后，订阅者回调执行onError。而merge会马上停止合并
startWith	源Observable提交结果之前，插入指定数据
switchOnNext	把一组Observable转换成Observable。这组Observable中取最后一个Observable提交的结果给订阅者。
==zip==	==把两个Observable提交的结果按照顺序进行合并。==
Error Handing Operators(Observable的错误处理操作符)
操作符	功能
onErrorReturn	在Observable 发生错误或异常（即将回调onError）时，拦截错误并执行指定的逻辑，返回一个跟源Observable相同类型的结果，最后回调订阅者的onComplete方法
onErrorResumeNext	like onErrorReturn 不同的是返回一个Observable 例：return Observable.just(5,2,0);
onExceptionResumeNext	like onErrorResumeNext 不同的是只有在exception的时候触发
==retry==	==当Observable发生错误或异常，重新执行Observable的逻辑，如果经过n次重新执行后仍然出现错误或异常，则最后回调onError方法，若无错误或异常则按正常流程执行 例：observable.retry(2).subscribe();==
retryWhen	like retry 不同在于retryWhen是在源Observable出现错误或异常时，通过回调第二个Observable来判断是否重新尝试执行源Observable的逻辑；若第二个Observable没错误或异常，则会重新尝试执行源Observable的逻辑，否则就会直接回调执行订阅者的onError();
其他常用
操作符	功能
map	对源Observable数据的加工处理,返回其他类型 例：return 520+”string data”;
flatMap	like map 不同的是返回一个Observable 扩展：使用了merge操作符 例：return Observable.from(…);
concatMap	like concatMap 不同的是concatMap操作遵循元素的顺序 扩展：使用了concat操作符
compose	唯一一个能从流中获取原生Observable的方法，因此，影响整个流的操作符（subscribeOn()和observeOn()）需要用compose()。当你创建一个Observable流并且内联了一堆操作符以后，compose()会立即执行，所以compose转换的是整个流
compose与flagMap的区别	flatMap()一定是低效率的，因为他每次调用onNext()之后都需要创建一个新的Observable，compose()是操作在整个流上的
concat	按顺序依次连接两个或更多的 Observable
first	从序列中取第一个先完成的项
takeFirst	like first 区别是first()如果没有释放有效的数据源,那么会throw NoSuchElementException;而takeFirst会complete没有 exception
常用场景
我们前面已经大致理解RxJava和他的基本使用了，虽然是冰山一角，但够我们入门了，现在我们来通过实际项目中常用的场景来进阶学习。
