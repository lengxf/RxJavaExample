#02.进入响应式

xJava的基本实现

因为RxJava2.0重构，更不符规范，我们在讲原理的时候，直接拿着2.0的代码来做示例，但是有些得放用2.0不太好理解，我们就用1.0的代码来理解原理

创建Subscriber(2.0)/Observer(2.0)
```
Subscriber<String> subscriber = new Subscriber<String>() {
            @Override
            public void onSubscribe(Subscription s) {
                Logger.i("hello onSubscribe");
            }

            @Override
            public void onNext(String s) {
                Logger.i("hello onNext-->" + s);
            }

            @Override
            public void onError(Throwable t) {
                Logger.i("hello onError");
            }

            @Override
            public void onComplete() {
                Logger.i("hello onComplete");
            }
        };

Observer<String> observer = new Observer<String>() {

            @Override
            public void onSubscribe(Disposable d) {
                Logger.i("hello onSubscribe");
            }

            @Override
            public void onNext(String value) {
                Logger.i("hello onNext-->" + value);
            }

            @Override
            public void onError(Throwable e) {
                Logger.i("hello onError");
            }

            @Override
            public void onComplete() {
                Logger.i("hello onComplete");
            }
        };
```

Subscriber 和 Observer的接口是分别独立的，Obsesrver用于订阅Observable，而Subscriber用于订阅Flowable

创建Flowable（2.0）/Observable（2.0）
Observable 即被观察者，它决定什么时候触发事件以及触发怎样的事件。 RxJava 使用 create()方法来创建一个Observable，并为它定义事件触发规则
```
Flowable<String> stringFlowable = Flowable.create(new FlowableOnSubscribe<String>() {
            @Override
            public void subscribe(FlowableEmitter<String> e) throws Exception {
                Logger.i("---rxHelloFlowable---");
            }
        }, FlowableEmitter.BackpressureMode.BUFFER);

Observable<String> stringObservable = Observable.create(new ObservableOnSubscribe<String>() {
            @Override
            public void subscribe(ObservableEmitter<String> e) throws Exception {
                e.onNext("Hello");
                e.onNext("Inke");
                e.onComplete();
            }
        });
 ```
可以看到，这里传入了一个 ObservableOnSubscribe对象作为参数，它的作用相当于一个计划表，当 Observable被订阅的时候，ObservableOnSubscribe的subscribe()方法会自动被调用，事件序列就会依照设定依次触发（对于上面的代码，就是观察者Subscriber 将会被调用两次 onNext()和一次 onCompleted()）。这样，由被观察者调用了观察者的回调方法，就实现了由被观察者向观察者的事件传递，即观察者模式。


RxJava提供快捷创建事件队列的方法

just()将传入的参数依次发送出来
fromIterable() 将传入的Iterable 拆分成具体对象后，依次发送出来
fromArray() 还没研究明白
心细的朋友可以看到Flowable在create()的时候多了一个参数 BackpressureMode，是用来处理backpressure的发射器 
一共有以下几种模式

enum BackpressureMode {
        /** * OnNext events are written without any buffering or dropping. * Downstream has to deal with any overflow. * <p>Useful when one applies one of the custom-parameter onBackpressureXXX operators. */
        NONE,
        /** * Signals a MissingBackpressureException in case the downstream can't keep up. */
        ERROR,
        /** * Buffers <em>all</em> onNext values until the downstream consumes it. */
        BUFFER,
        /** * Drops the most recent onNext value if the downstream can't keep up. */
        DROP,
        /** * Keeps only the latest onNext value, overwriting any previous value if the * downstream can't keep up. */
        LATEST
    }
个人感觉BUFFER较为安全，api解释为缓冲器存有onNext值，直到下游消费它。

因为Observer不支持 backpressure，所以后面的代码我们默认使用RxJava2.0的Flowable和Subscriber，但是为了便于理解，某些原理可能还会用RxJava1.0。

Subscribe （订阅）
创建了 Flowable和 Subscriber 之后，再用 subscribe()方法将它们联结起来，整条链子就可以工作了。


订阅过程做了三件事

调用 Subscriber.onSubscribe()。是Rx2.0新添加的方法，第一个执行
调用 FlowableOnSubscribe中的subscribe() 。在这里，事件发送的逻辑开始运行。从这也可以看出，在 RxJava 中，Flowable并不是在创建的时候就立即开始发送事件，而是在它被订阅的时候，即当 subscribe()方法执行的时候。
上面我们可以看到，通过subscriber来订阅返回的是void 
在RxJava2.0 如果是直接订阅或传入消费者那么会产生一个新的类 
那就是Disposable

/** 
* Represents a disposable resource. 
*/ 
代表一个一次性的资源。 
代码如下

Disposable subscribe = stringFlowable.subscribe(new Consumer<String>() {
            @Override
            public void accept(String s) throws Exception {

            }
        });
订阅源码如下

public final Disposable subscribe(Consumer<? super T> onNext, Consumer<? super Throwable> onError, 
            Action onComplete, Consumer<? super Subscription> onSubscribe) {
        LambdaSubscriber<T> ls = new LambdaSubscriber<T>(onNext, onError, onComplete, onSubscribe);

        subscribe(ls);

        return ls;
    }
    
不过最终走的还是上面的逻辑，不过多返回了一个Disposable， 
用于dispose();





##工厂方法（just，from，create，and others）


###



##Observers


##Hot and Cold observables

##connectable observables

##subjects

##creation

```
Flowable.create((FlowableEmitter<Integer> emitter) -> {
    emitter.onNext(1);
    emitter.onNext(2);
    emitter.onComplete();
}, BackpressureStrategy.BUFFER);
```

