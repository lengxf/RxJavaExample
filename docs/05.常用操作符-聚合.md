#Aggregation

前面介绍了如何过滤掉不需要的数据、如何根据各种条件停止发射数据、如何检查数据是否符合某个条件。这些操作对数据流来说都是非常有意义的。 本节介绍如何根据数据流中的数据来生成新的有意义的数据。
本节的操作函数会使用源 Observable 中的事件流中的数据，然后把这些数据转换为其他类型的数据。返回结果是包含一个数据的 Observable。
如果你从头开始阅读本系列教程，则会发现前面代码中有很多重复的地方。 为了避免重复代码并且使代码更加简洁，方便我们聚焦要介绍的函数，从本节开始在示例代码中会引入一个自定义的 Subscriber 。该 Subscribe 用来订阅 Observable 并打印结果：
```Java

class PrintSubscriber extends Subscriber{
    private final String name;
    public PrintSubscriber(String name) {
        this.name = name;
    }
    @Override
    public void onCompleted() {
        System.out.println(name + ": Completed");
    }
    @Override
    public void onError(Throwable e) {
        System.out.println(name + ": Error: " + e);
    }
    @Override
    public void onNext(Object v) {
        System.out.println(name + ": " + v);
    }
}
```

很简单的一个自定义实现，打印每个事件并使用一个 TAG 来标记是那个 Subscriber.

##count

count 函数和 Java 集合中的 size 或者 length 一样。用来统计源 Observable 完成的时候一共发射了多少个数据。
![image](rxcount.png)
``Java

Observable<Integer> values = Observable.range(0, 3);

values
    .subscribe(new PrintSubscriber("Values"));
values
    .count()
    .subscribe(new PrintSubscriber("Count"));
```

 
结果：
```Java

Values: 0
Values: 1
Values: 2
Values: Completed
Count: 3
Count: Completed

如果发射数据的个数超过了 int 最大值，则可以使用 countLong 函数。

first

first 类似于 take(1) , 发射 源 Observable 中的第一个数据。如果没有数据，则返回 ava.util.NoSuchElementException。还有一个重载的带有 过滤 参数，则返回第一个满足该条件的数据。
```Java

Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values
    .first(v -> v>5)
    .subscribe(new PrintSubscriber("First"));
```

 
结果：
```Java

First: 6
```

 
可以使用 firstOrDefault 来避免 java.util.NoSuchElementException 错误信息，这样如果没有发现数据，则发射一个默认的数据。
last

last 和 lastOrDefault 是和 first 一样的，区别就是当 源 Observable 完成的时候， 发射最后的数据。 如果使用重载的带 过滤参数的函数，则返回最后一个满足该条件的数据。 从后面开始，这种和前面功能非常类似的示例代码就省略了。但是你可以在示例代码中查看这些省略的示例。

##single

single 只会发射源 Observable 中的一个数据，如果使用重载的带过滤条件的函数，则发射符合该过滤条件的那个数据。和 first 、last 不一样的地方是，single 会检查数据流中是否只包含一个所需要的的数据，如果有多个则会抛出一个错误信息。所以 single 用来检查数据流中是否有且仅有一个符合条件的数据。所以 single 只有在源 Observable 完成后才能返回。
![image](rxsingle.png)
```Java

Observable<Long> values = Observable.interval(100, TimeUnit.MILLISECONDS);

values.take(10) // 获取前 10 个数据 的 Observable
    .single(v -> v == 5L) // 有且仅有一个 数据为 5L
    .subscribe(new PrintSubscriber("Single1"));
values
    .single(v -> v == 5L) // 由于源 Observable 为无限的，所以这个不会打印任何东西
    .subscribe(new PrintSubscriber("Single2"));
```

 
结果：
```Java

Single1: 5
Single1: Completed
``

 
和前面的类似，使用 singleOrDefault 可以返回一个默认值。

#Custom aggregators（自定义聚合）


本节前面介绍的几个函数，和之前看到的也没太大区别。下面会介绍两个非常强大的操作函数，可以很方便的来扩展源 Observable。 之前所介绍的所有操作函数都可以通过这两个函数来实现。

##reduce

你可能从 MapReduce 中了解过 reduce。该思想是使用源 Observable 中的所有数据两两组合来生成一个单一的 数据。在大部分重载函数中都需要一个函数用来定义如何组合两个数据变成一个。
```Java

public final Observable<T> reduce(Func2<T,T,T> accumulator)
```
![image](rxreduce.png)
下面的示例是最好的解释。示例代码的第一个功能是对数据流中所有整数求和（0+1+2+3+4+…）。第二个功能是找出所有整数中最小的那个。
```Java

Observable<Integer> values = Observable.range(0,5);

values
    .reduce((i1,i2) -> i1+i2)
    .subscribe(new PrintSubscriber("Sum"));
values
    .reduce((i1,i2) -> (i1>i2) ? i2 : i1)
    .subscribe(new PrintSubscriber("Min"));
```

 
结果：
Java

Sum: 10
Sum: Completed
Min: 0
Min: Completed

Rx 中的 reduce 和并行系统中的 reduce 不一样。在并行系统中的 reduce 是指，计算的取值是不相关的，这样多个机器可以独立并行工作。在 Rx 中是使用从数据流中第一个数据到最后一个数据（从左往右）中的数据来调用 参数 accumulator ，accumulator 用前一次返回的结果和下一个数据来再次调用 accumulator 。 下面这个重载函数更加暴露了这个设计意图。
```Java

public final <R> Observable<R> reduce(R initialValue, Func2<R,? super T,R> accumulator)
```
 
accumulator 参数返回的数据类型和 源 Observable 的数据类型可能是不一样的。accumulator 的第一个参数为前一步 accumulator 执行的结果，而第二个参数为 下一个数据。 使用一个初始化的值作为整个处理流程的开始。下面的示例通过重新实现 count 函数来演示 reduce 的使用：
```Java

Observable<String> values = Observable.just("Rx", "is", "easy");

values
    .reduce(0, (acc,next) -> acc + 1)
    .subscribe(new PrintSubscriber("Count"));
```
 
结果：
```Java

Count: 3
Count: Completed
```
 
上面示例中的 accumulator 参数为 (acc,next) -> acc + 1 这个 Lambda 表达式，该表达式需要两个参数 acc 和next， 当第一个数据从 源 Observable 发射出来的时候，由于 Lambda 表达式还没有调用过，所以使用 初始值 0 来替代 acc ，使用第一个字符串“Rx” 来调用 accumulator 参数，这样 (acc,next) -> acc + 1 表达式返回的值就是 acc + 1 （而 acc 为初始值 0 ，所以返回 1， 可以看到 这个 next 参数 为源 Observable 的值在这里是没有用的）；这样 源Observable 每次发射一个数据， Lambda 就把上一次的结果加1 返回。和 count 的功能一样。
对于前面只返回一个数据结果的操作函数，大部分都可以通过 reduce 来实现。对于那些 源 Observable 没有完成就返回的操作函数来说，是不能使用 reduce 来实现的。所以 可以用 reduce 来实现 last，但是用 reduce 实现的 all 函数和原来的 all 是不太一样的。

##scan

scan 和 reduce 很像，不一样的地方在于 scan会发射所有中间的结算结果。
``Java

public final Observable<T> scan(Func2<T,T,T> accumulator)
``

![image](rxscan.png)

通过上图可以看到和 reduce 的区别， reduce 只是最后把计算结果发射出来，而 scan 把每次的计算结果都发射出来。
```Java

Observable<Integer> values = Observable.range(0,5);

values
    .scan((i1,i2) -> i1+i2)
    .subscribe(new PrintSubscriber("Sum"));
```

结果：
```Java

Sum: 0
Sum: 1
Sum: 3
Sum: 6
Sum: 10
Sum: Completed
```
 
reduce 可以通过 scan 来实现： reduce(acc) = scan(acc).takeLast() 。所以 scan 比 reduce 更加通用。
源 Observable 发射数据，经过 scan 处理后 scan 也发射一个处理后的数据，所以 scan 并不要求源 Observable 完成发射。下面示例实现了 查找已经发射数据中的最小值的功能：
```Java

Subject<Integer, Integer> values = ReplaySubject.create();

values
    .subscribe(new PrintSubscriber("Values"));
values
    .scan((i1,i2) -> (i1<i2) ? i1 : i2)
    .distinctUntilChanged()
    .subscribe(new PrintSubscriber("Min"));

values.onNext(2);
values.onNext(3);
values.onNext(1);
values.onNext(4);
values.onCompleted();
```

 
结果：
```Java

Values: 2
Min: 2
Values: 3
Values: 1
Min: 1
Values: 4
Values: Completed
Min: Completed
```
